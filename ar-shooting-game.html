<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR Gesture Shooting Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #camera-feed {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            object-fit: cover;
            transform: scaleX(-1);
            z-index: 1;
        }

        #landmark-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            object-fit: cover;
            transform: scaleX(-1);
            z-index: 2;
            pointer-events: none;
        }

        #game-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 3;
            pointer-events: none;
        }

        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 0.5s ease;
        }

        #loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loader-title {
            color: #e94560;
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 2rem;
            text-shadow: 0 0 20px rgba(233, 69, 96, 0.5);
        }

        .loader-spinner {
            width: 80px;
            height: 80px;
            border: 4px solid rgba(233, 69, 96, 0.2);
            border-top-color: #e94560;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 2rem;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .loader-text {
            color: #fff;
            font-size: 1.2rem;
            opacity: 0.8;
        }

        .loader-progress {
            width: 300px;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            margin-top: 1rem;
            overflow: hidden;
        }

        .loader-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #e94560, #ff6b6b);
            border-radius: 3px;
            width: 0%;
            transition: width 0.3s ease;
        }

        #score-display {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #fff;
            font-size: 1.5rem;
            font-weight: bold;
            z-index: 10;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        #score-display span {
            color: #e94560;
        }

        #debug-info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.8rem;
            z-index: 10;
        }
    </style>
</head>

<body>
    <div id="loading-overlay">
        <div class="loader-title">ðŸŽ¯ AR SHOOTER</div>
        <div class="loader-spinner"></div>
        <div class="loader-text">Loading hand tracking model...</div>
        <div class="loader-progress">
            <div class="loader-progress-bar" id="progress-bar"></div>
        </div>
    </div>

    <video id="camera-feed" autoplay muted></video>
    <canvas id="landmark-canvas"></canvas>
    <canvas id="game-canvas"></canvas>

    <div id="score-display">Score: <span id="score">0</span></div>
    <div id="debug-info">Gesture: <span id="gesture-status">Waiting...</span></div>

    <script src="https://unpkg.com/three@0.152.0/build/three.min.js"></script>
    <script src="https://unpkg.com/@mediapipe/hands@0.4.1646424915/hands.js"></script>
    <script src="https://unpkg.com/@mediapipe/camera_utils@0.3.1640029074/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

    <script>
        // ============================================
        // CONFIGURATION
        // ============================================
        const CONFIG = {
            DISC_COUNT: 4,
            DISC_SPEED: 0.015,
            DISC_SIZE: 0.12,
            AIM_ASSIST_RADIUS: 0.15,
            DETECTION_INTERVAL: 66, // ~15 FPS for hand detection
            LASER_COLOR: 0xff0000,
            CROSSHAIR_COLOR: 0x00ff00,
            HIT_COLOR: 0x00ff00,
            MISS_COLOR: 0xff0000
        };

        // ============================================
        // GAME STATE
        // ============================================
        let score = 0;
        let handsReady = false;
        let lastDetectionTime = 0;
        let lastHandData = null;
        let isPistolGesture = false;
        let wasTriggerPulled = false;
        let aimPosition = { x: 0, y: 0 };
        let assistedAimPosition = { x: 0, y: 0 };

        // ============================================
        // DOM ELEMENTS
        // ============================================
        const loadingOverlay = document.getElementById('loading-overlay');
        const progressBar = document.getElementById('progress-bar');
        const loaderText = document.querySelector('.loader-text');
        const cameraFeed = document.getElementById('camera-feed');
        const gameCanvas = document.getElementById('game-canvas');
        const landmarkCanvas = document.getElementById('landmark-canvas');
        const landmarkCtx = landmarkCanvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const gestureStatus = document.getElementById('gesture-status');

        // ============================================
        // THREE.JS SETUP
        // ============================================
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 1;

        const renderer = new THREE.WebGLRenderer({
            canvas: gameCanvas,
            alpha: true,
            antialias: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0xff6b6b, 1, 100);
        pointLight.position.set(0, 0, 2);
        scene.add(pointLight);

        // ============================================
        // GAME OBJECTS
        // ============================================
        const discs = [];
        const textEffects = [];
        const particles = [];

        // Disc material
        const discMaterial = new THREE.MeshPhongMaterial({
            color: 0xe94560,
            emissive: 0x441122,
            shininess: 100,
            side: THREE.DoubleSide
        });

        // Create disc geometry
        const discGeometry = new THREE.TorusGeometry(CONFIG.DISC_SIZE, CONFIG.DISC_SIZE * 0.3, 8, 24);

        // Laser line
        const laserMaterial = new THREE.LineBasicMaterial({
            color: CONFIG.LASER_COLOR,
            linewidth: 2,
            transparent: true,
            opacity: 0.8
        });
        const laserGeometry = new THREE.BufferGeometry();
        const laserLine = new THREE.Line(laserGeometry, laserMaterial);
        laserLine.visible = false;
        scene.add(laserLine);

        // Crosshair
        const crosshairGroup = new THREE.Group();
        const crosshairRingGeometry = new THREE.RingGeometry(0.03, 0.04, 32);
        const crosshairMaterial = new THREE.MeshBasicMaterial({
            color: CONFIG.CROSSHAIR_COLOR,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.8
        });
        const crosshairRing = new THREE.Mesh(crosshairRingGeometry, crosshairMaterial);
        crosshairGroup.add(crosshairRing);

        // Crosshair dot
        const dotGeometry = new THREE.CircleGeometry(0.008, 16);
        const dotMesh = new THREE.Mesh(dotGeometry, crosshairMaterial);
        crosshairGroup.add(dotMesh);

        crosshairGroup.visible = false;
        scene.add(crosshairGroup);

        // ============================================
        // AUDIO SYSTEM (Web Audio API)
        // ============================================
        let audioContext = null;

        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
                console.warn('Web Audio API not supported');
            }
        }

        function playHitSound() {
            if (!audioContext) return;
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.1);

                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);

                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.15);
            } catch (e) {
                console.warn('Audio error:', e);
            }
        }

        function playMissSound() {
            if (!audioContext) return;
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(150, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(80, audioContext.currentTime + 0.2);

                gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);

                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.2);
            } catch (e) {
                console.warn('Audio error:', e);
            }
        }

        function playShootSound() {
            if (!audioContext) return;
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.1, audioContext.sampleRate);
                const noiseData = noiseBuffer.getChannelData(0);

                for (let i = 0; i < noiseData.length; i++) {
                    noiseData[i] = Math.random() * 2 - 1;
                }

                const noiseSource = audioContext.createBufferSource();
                noiseSource.buffer = noiseBuffer;

                const noiseGain = audioContext.createGain();
                noiseSource.connect(noiseGain);
                noiseGain.connect(audioContext.destination);

                noiseGain.gain.setValueAtTime(0.3, audioContext.currentTime);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);

                noiseSource.start();
            } catch (e) {
                console.warn('Audio error:', e);
            }
        }

        // ============================================
        // DISC MANAGEMENT
        // ============================================
        function createDisc() {
            const disc = new THREE.Mesh(discGeometry, discMaterial.clone());

            // Random edge spawn position
            const edge = Math.floor(Math.random() * 4);
            const aspect = window.innerWidth / window.innerHeight;

            switch (edge) {
                case 0: // Top
                    disc.position.set((Math.random() - 0.5) * 2 * aspect, 1.2, 0);
                    break;
                case 1: // Bottom
                    disc.position.set((Math.random() - 0.5) * 2 * aspect, -1.2, 0);
                    break;
                case 2: // Left
                    disc.position.set(-aspect - 0.2, (Math.random() - 0.5) * 2, 0);
                    break;
                case 3: // Right
                    disc.position.set(aspect + 0.2, (Math.random() - 0.5) * 2, 0);
                    break;
            }

            // Target center with slight randomness
            disc.userData.target = new THREE.Vector3(
                (Math.random() - 0.5) * 0.3,
                (Math.random() - 0.5) * 0.3,
                0
            );

            // Random rotation
            disc.rotation.x = Math.random() * Math.PI;
            disc.rotation.y = Math.random() * Math.PI;
            disc.userData.rotationSpeed = {
                x: (Math.random() - 0.5) * 0.1,
                y: (Math.random() - 0.5) * 0.1,
                z: (Math.random() - 0.5) * 0.1
            };

            // Random color variation
            disc.material.color.setHSL(Math.random() * 0.1 + 0.95, 0.8, 0.5);

            scene.add(disc);
            discs.push(disc);
            return disc;
        }

        function updateDiscs() {
            for (let i = discs.length - 1; i >= 0; i--) {
                const disc = discs[i];

                // Move toward target
                const direction = new THREE.Vector3()
                    .subVectors(disc.userData.target, disc.position)
                    .normalize();
                disc.position.add(direction.multiplyScalar(CONFIG.DISC_SPEED));

                // Rotate
                disc.rotation.x += disc.userData.rotationSpeed.x;
                disc.rotation.y += disc.userData.rotationSpeed.y;
                disc.rotation.z += disc.userData.rotationSpeed.z;

                // Check if disc reached center (player loses if too close)
                if (disc.position.distanceTo(disc.userData.target) < 0.05) {
                    scene.remove(disc);
                    discs.splice(i, 1);
                }
            }

            // Maintain disc count
            while (discs.length < CONFIG.DISC_COUNT) {
                createDisc();
            }
        }

        // ============================================
        // TEXT EFFECTS
        // ============================================
        function createTextEffect(text, position, color) {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');

            ctx.font = 'bold 64px Arial';
            ctx.fillStyle = color === CONFIG.HIT_COLOR ? '#00ff00' : '#ff0000';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = color === CONFIG.HIT_COLOR ? '#00ff00' : '#ff0000';
            ctx.shadowBlur = 20;
            ctx.fillText(text, 128, 64);

            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                opacity: 1
            });
            const sprite = new THREE.Sprite(material);
            sprite.position.copy(position);
            sprite.scale.set(0.3, 0.15, 1);
            sprite.userData.velocity = new THREE.Vector3(0, 0.02, 0);
            sprite.userData.life = 1;

            scene.add(sprite);
            textEffects.push(sprite);
        }

        function updateTextEffects() {
            for (let i = textEffects.length - 1; i >= 0; i--) {
                const effect = textEffects[i];
                effect.position.add(effect.userData.velocity);
                effect.userData.life -= 0.02;
                effect.material.opacity = effect.userData.life;

                if (effect.userData.life <= 0) {
                    scene.remove(effect);
                    effect.material.dispose();
                    effect.material.map.dispose();
                    textEffects.splice(i, 1);
                }
            }
        }

        // ============================================
        // PARTICLE EFFECTS
        // ============================================
        function createShatterEffect(position, color) {
            const particleCount = 15;
            for (let i = 0; i < particleCount; i++) {
                const geometry = new THREE.BoxGeometry(0.02, 0.02, 0.02);
                const material = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 1
                });
                const particle = new THREE.Mesh(geometry, material);
                particle.position.copy(position);
                particle.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.1,
                    (Math.random() - 0.5) * 0.1,
                    (Math.random() - 0.5) * 0.1
                );
                particle.userData.life = 1;
                scene.add(particle);
                particles.push(particle);
            }
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                particle.position.add(particle.userData.velocity);
                particle.userData.velocity.y -= 0.003; // Gravity
                particle.userData.life -= 0.03;
                particle.material.opacity = particle.userData.life;
                particle.rotation.x += 0.1;
                particle.rotation.y += 0.1;

                if (particle.userData.life <= 0) {
                    scene.remove(particle);
                    particle.geometry.dispose();
                    particle.material.dispose();
                    particles.splice(i, 1);
                }
            }
        }

        // ============================================
        // GESTURE DETECTION
        // ============================================
        function detectPistolGesture(landmarks) {
            if (!landmarks || landmarks.length < 21) return { isPistol: false, isTrigger: false };

            // Finger tip and base indices
            const INDEX_TIP = 8;
            const INDEX_MCP = 5;
            const MIDDLE_TIP = 12;
            const MIDDLE_MCP = 9;
            const RING_TIP = 16;
            const RING_MCP = 13;
            const PINKY_TIP = 20;
            const PINKY_MCP = 17;
            const THUMB_TIP = 4;
            const THUMB_IP = 3;
            const WRIST = 0;

            // Check if index finger is extended
            const indexExtended = landmarks[INDEX_TIP].y < landmarks[INDEX_MCP].y - 0.05;

            // Check if other fingers are curled
            const middleCurled = landmarks[MIDDLE_TIP].y > landmarks[MIDDLE_MCP].y - 0.03;
            const ringCurled = landmarks[RING_TIP].y > landmarks[RING_MCP].y - 0.03;
            const pinkyCurled = landmarks[PINKY_TIP].y > landmarks[PINKY_MCP].y - 0.03;

            // Check if thumb is up (trigger pulled)
            const thumbUp = landmarks[THUMB_TIP].y < landmarks[THUMB_IP].y - 0.02;

            const isPistol = indexExtended && middleCurled && ringCurled && pinkyCurled;

            return {
                isPistol: isPistol,
                isTrigger: thumbUp,
                aimX: 1 - landmarks[INDEX_TIP].x, // Mirror for display
                aimY: landmarks[INDEX_TIP].y
            };
        }

        // ============================================
        // MAGNETIC AIM ASSIST
        // ============================================
        function applyAimAssist(aimX, aimY) {
            const aspect = window.innerWidth / window.innerHeight;
            let worldX = (aimX - 0.5) * 2 * aspect;
            let worldY = -(aimY - 0.5) * 2;

            let closestDisc = null;
            let closestDist = CONFIG.AIM_ASSIST_RADIUS;

            for (const disc of discs) {
                const dist = Math.sqrt(
                    Math.pow(disc.position.x - worldX, 2) +
                    Math.pow(disc.position.y - worldY, 2)
                );
                if (dist < closestDist) {
                    closestDist = dist;
                    closestDisc = disc;
                }
            }

            if (closestDisc) {
                // Magnetic attraction
                const strength = 1 - (closestDist / CONFIG.AIM_ASSIST_RADIUS);
                worldX = worldX + (closestDisc.position.x - worldX) * strength * 0.7;
                worldY = worldY + (closestDisc.position.y - worldY) * strength * 0.7;

                // Change crosshair color to indicate lock
                crosshairMaterial.color.setHex(0xff6600);
            } else {
                crosshairMaterial.color.setHex(CONFIG.CROSSHAIR_COLOR);
            }

            return { x: worldX, y: worldY, lockedDisc: closestDisc };
        }

        // ============================================
        // SHOOTING
        // ============================================
        function shoot(aimX, aimY) {
            playShootSound();

            const { x: worldX, y: worldY, lockedDisc } = applyAimAssist(aimX, aimY);

            let hit = false;

            // Check hit on all discs
            for (let i = discs.length - 1; i >= 0; i--) {
                const disc = discs[i];
                const dist = Math.sqrt(
                    Math.pow(disc.position.x - worldX, 2) +
                    Math.pow(disc.position.y - worldY, 2)
                );

                if (dist < CONFIG.DISC_SIZE * 1.5) {
                    // Hit!
                    hit = true;
                    score += 100;
                    scoreElement.textContent = score;

                    createTextEffect('HIT!', disc.position.clone(), CONFIG.HIT_COLOR);
                    createShatterEffect(disc.position.clone(), disc.material.color.getHex());
                    playHitSound();

                    scene.remove(disc);
                    discs.splice(i, 1);
                    break;
                }
            }

            if (!hit) {
                createTextEffect('MISS', new THREE.Vector3(worldX, worldY, 0), CONFIG.MISS_COLOR);
                playMissSound();
            }
        }

        // ============================================
        // MEDIAPIPE HANDS SETUP
        // ============================================
        async function initMediaPipe() {
            try {
                progressBar.style.width = '20%';
                loaderText.textContent = 'Initializing camera...';

                // Get camera stream
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 1280, height: 720, facingMode: 'user' }
                });
                cameraFeed.setAttribute('playsinline', '');
                cameraFeed.srcObject = stream;
                await cameraFeed.play();

                progressBar.style.width = '40%';
                loaderText.textContent = 'Loading hand tracking model...';

                // Initialize MediaPipe Hands with version-locked resources
                const hands = new Hands({
                    locateFile: (file) => {
                        return `https://unpkg.com/@mediapipe/hands@0.4.1646424915/${file}`;
                    }
                });

                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.7,
                    minTrackingConfidence: 0.5
                });

                progressBar.style.width = '60%';
                loaderText.textContent = 'Downloading model weights...';

                hands.onResults((results) => {
                    // Update Landmarks Canvas size if needed
                    if (landmarkCanvas.width !== window.innerWidth || landmarkCanvas.height !== window.innerHeight) {
                        landmarkCanvas.width = window.innerWidth;
                        landmarkCanvas.height = window.innerHeight;
                    }

                    // Draw Landmarks
                    landmarkCtx.save();
                    landmarkCtx.clearRect(0, 0, landmarkCanvas.width, landmarkCanvas.height);
                    if (results.multiHandLandmarks) {
                        landmarkCtx.shadowBlur = 15;
                        landmarkCtx.shadowColor = '#00FF00';
                        for (const landmarks of results.multiHandLandmarks) {
                            drawConnectors(landmarkCtx, landmarks, HAND_CONNECTIONS,
                                { color: '#00FF00', lineWidth: 4 });
                            drawLandmarks(landmarkCtx, landmarks,
                                { color: '#00FFFF', lineWidth: 1, radius: 2 });
                        }
                    }
                    landmarkCtx.restore();

                    try {
                        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                            lastHandData = results.multiHandLandmarks[0];
                        } else {
                            lastHandData = null;
                        }
                    } catch (e) {
                        console.warn('Hand result processing error:', e);
                    }
                });

                // Initialize model by sending a frame
                progressBar.style.width = '80%';
                loaderText.textContent = 'Warming up model...';

                await hands.send({ image: cameraFeed });

                progressBar.style.width = '100%';
                loaderText.textContent = 'Ready!';

                // Start detection loop
                setInterval(async () => {
                    try {
                        await hands.send({ image: cameraFeed });
                    } catch (e) {
                        console.warn('Hand detection error:', e);
                    }
                }, CONFIG.DETECTION_INTERVAL);

                handsReady = true;

                // Hide loading overlay
                setTimeout(() => {
                    loadingOverlay.classList.add('hidden');
                    initAudio();
                }, 500);

            } catch (error) {
                console.error('MediaPipe initialization error:', error);
                loaderText.textContent = 'Error: ' + error.message;
                loaderText.style.color = '#ff0000';
            }
        }

        // ============================================
        // GAME LOOP
        // ============================================
        function updateAiming() {
            if (!lastHandData) {
                laserLine.visible = false;
                crosshairGroup.visible = false;
                gestureStatus.textContent = 'No hand detected';
                isPistolGesture = false;
                return;
            }

            try {
                const gesture = detectPistolGesture(lastHandData);

                if (gesture.isPistol) {
                    isPistolGesture = true;
                    gestureStatus.textContent = gesture.isTrigger ? 'ðŸ”« FIRING!' : 'ðŸ”« Aiming...';

                    // Update aim position
                    aimPosition.x = gesture.aimX;
                    aimPosition.y = gesture.aimY;

                    // Apply aim assist
                    const assisted = applyAimAssist(aimPosition.x, aimPosition.y);
                    assistedAimPosition.x = assisted.x;
                    assistedAimPosition.y = assisted.y;

                    // Update crosshair
                    crosshairGroup.position.set(assistedAimPosition.x, assistedAimPosition.y, 0.1);
                    crosshairGroup.visible = true;

                    // Update laser
                    const aspect = window.innerWidth / window.innerHeight;
                    const handX = (aimPosition.x - 0.5) * 2 * aspect;
                    const handY = -(aimPosition.y - 0.5) * 2;

                    const positions = new Float32Array([
                        handX, handY - 0.3, 0,
                        assistedAimPosition.x, assistedAimPosition.y, 0.1
                    ]);
                    laserGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    laserLine.visible = true;

                    // Check for trigger pull (rising edge)
                    if (gesture.isTrigger && !wasTriggerPulled) {
                        shoot(aimPosition.x, aimPosition.y);
                    }
                    wasTriggerPulled = gesture.isTrigger;

                } else {
                    isPistolGesture = false;
                    laserLine.visible = false;
                    crosshairGroup.visible = false;
                    gestureStatus.textContent = 'Make pistol gesture ðŸ‘†';
                    wasTriggerPulled = false;
                }
            } catch (e) {
                console.warn('Aiming update error:', e);
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            if (handsReady) {
                updateDiscs();
                updateAiming();
                updateTextEffects();
                updateParticles();
            }

            renderer.render(scene, camera);
        }

        // ============================================
        // WINDOW RESIZE
        // ============================================
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ============================================
        // INITIALIZE
        // ============================================
        // Initialize discs
        for (let i = 0; i < CONFIG.DISC_COUNT; i++) {
            createDisc();
        }

        // Start animation loop
        animate();

        // Initialize MediaPipe
        initMediaPipe();
    </script>
</body>

</html>