<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Strike AR</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe Hands pinned version for stability -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: sans-serif;
        }

        #video-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            transform: scaleX(-1);
            background: #000;
        }

        #input_video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #output_canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 10;
        }

        #ui-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 2rem;
            z-index: 20;
        }

        .vfx-text {
            position: absolute;
            font-weight: bold;
            font-size: 2rem;
            pointer-events: none;
            animation: floatUp 0.8s ease-out forwards;
        }

        @keyframes floatUp {
            0% {
                transform: translateY(0);
                opacity: 1;
            }

            100% {
                transform: translateY(-100px);
                opacity: 0;
            }
        }

        #loading-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            transition: opacity 0.5s;
        }

        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 2s linear infinite;
            margin-bottom: 1rem;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body>

    <div id="loading-overlay">
        <div class="loader"></div>
        <p id="loading-text" class="text-white text-lg">Initializing Neural Networks...</p>
    </div>

    <div id="video-container">
        <video id="input_video" autoplay muted></video>
        <canvas id="output_canvas"></canvas>
    </div>
    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div class="w-full flex justify-between items-start">
            <div class="bg-black/50 p-4 rounded-xl border border-white/20">
                <p class="text-xs uppercase opacity-70">Score</p>
                <p id="score-val" class="text-3xl font-mono">0000</p>
            </div>
            <div class="bg-black/50 p-4 rounded-xl border border-white/20 text-right">
                <p class="text-xs uppercase opacity-70">Status</p>
                <p id="gesture-status" class="text-sm font-bold text-red-400">HAND NOT DETECTED</p>
            </div>
        </div>

        <div id="crosshair"
            class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-8 h-8 pointer-events-none">
            <div class="absolute inset-0 border-2 border-cyan-400 rounded-full animate-pulse"></div>
            <div class="absolute top-1/2 left-0 w-full h-0.5 bg-cyan-400"></div>
            <div class="absolute left-1/2 top-0 w-0.5 h-full bg-cyan-400"></div>
        </div>

        <div class="mb-8 text-center bg-black/40 px-6 py-2 rounded-full backdrop-blur-sm">
            <p class="text-sm">Aim with Index Finger Â· Pull Thumb to Fire</p>
        </div>
    </div>

    <script>
        // Game State
        const state = {
            score: 0,
            handDetected: false,
            lastTriggerState: false, // true = thumb closed (firing)
            isInitialized: false,
            enemyCount: 4,
            enemies: [],
            vfx: []
        };

        const scoreEl = document.getElementById('score-val');
        const statusEl = document.getElementById('gesture-status');
        const loadingOverlay = document.getElementById('loading-overlay');
        const loadingText = document.getElementById('loading-text');

        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');

        // Audio Setup (Synthetic SFX)
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSfx(freq, type = 'square', duration = 0.1) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(10, audioCtx.currentTime + duration);
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + duration);
        }

        // Three.js Setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const light = new THREE.PointLight(0xffffff, 1, 100);
        light.position.set(0, 5, 5);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0x404040));

        // Laser Aiming Line
        const laserMaterial = new THREE.LineBasicMaterial({ color: 0x00ffff });
        const laserGeometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -10)]);
        const laserLine = new THREE.Line(laserGeometry, laserMaterial);
        scene.add(laserLine);
        laserLine.visible = false;

        // Enemy Object
        class Enemy {
            constructor() {
                this.mesh = this.createMesh();
                this.reset();
                scene.add(this.mesh);
            }

            createMesh() {
                const group = new THREE.Group();
                const geometry = new THREE.CylinderGeometry(0.5, 0.5, 0.1, 16);
                const material = new THREE.MeshPhongMaterial({ color: 0xff3366, emissive: 0x330000 });
                const disc = new THREE.Mesh(geometry, material);
                disc.rotation.x = Math.PI / 2;
                group.add(disc);

                const ringGeo = new THREE.TorusGeometry(0.6, 0.05, 8, 24);
                const ringMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                group.add(ring);

                return group;
            }

            reset() {
                const angle = Math.random() * Math.PI * 2;
                const dist = 10 + Math.random() * 5;
                this.mesh.position.set(Math.cos(angle) * dist, Math.sin(angle) * dist, -10 - Math.random() * 5);
                this.targetPos = new THREE.Vector3(0, 0, -5);
                this.speed = 0.02 + Math.random() * 0.03;
                this.alive = true;
                this.mesh.scale.set(1, 1, 1);
            }

            update() {
                if (!this.alive) return;
                const dir = new THREE.Vector3().subVectors(this.targetPos, this.mesh.position).normalize();
                this.mesh.position.addScaledVector(dir, this.speed);
                this.mesh.rotation.y += 0.05;
                this.mesh.rotation.z += 0.02;

                // If passed center
                if (this.mesh.position.z > 0) this.reset();
            }

            shatter() {
                this.alive = false;
                playSfx(440, 'sine', 0.2);
                createVfxText("HIT", this.mesh.position);

                // Shrink and reset
                let s = 1.0;
                const shrink = () => {
                    s *= 0.8;
                    this.mesh.scale.set(s, s, s);
                    if (s > 0.1) requestAnimationFrame(shrink);
                    else this.reset();
                };
                shrink();
            }
        }

        // Initialize Enemies
        for (let i = 0; i < state.enemyCount; i++) {
            state.enemies.push(new Enemy());
        }

        function createVfxText(txt, pos) {
            const vector = pos.clone().project(camera);
            const x = (vector.x + 1) / 2 * window.innerWidth;
            const y = -(vector.y - 1) / 2 * window.innerHeight;

            const div = document.createElement('div');
            div.className = 'vfx-text';
            div.innerText = txt;
            div.style.left = `${x}px`;
            div.style.top = `${y}px`;
            div.style.color = txt === "HIT" ? "#4ade80" : "#f87171";
            document.body.appendChild(div);
            setTimeout(() => div.remove(), 800);
        }

        // MediaPipe Integration
        const videoElement = document.getElementById('input_video');
        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });

        function onResults(results) {
            // Draw Hand Landmarks
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            if (results.multiHandLandmarks) {
                canvasCtx.shadowBlur = 15;
                canvasCtx.shadowColor = '#00FF00';
                for (const landmarks of results.multiHandLandmarks) {
                    drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS,
                        { color: '#00FF00', lineWidth: 4 });
                    drawLandmarks(canvasCtx, landmarks, { color: '#00FFFF', lineWidth: 1, radius: 2 });
                }
            }
            canvasCtx.restore();

            try {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    state.handDetected = true;
                    statusEl.innerText = "WEAPON ACTIVE";
                    statusEl.className = "text-sm font-bold text-cyan-400";

                    const landmarks = results.multiHandLandmarks[0];
                    processGesture(landmarks);
                } else {
                    state.handDetected = false;
                    statusEl.innerText = "HAND NOT DETECTED";
                    statusEl.className = "text-sm font-bold text-red-400";
                    laserLine.visible = false;
                }
            } catch (err) {
                console.error("Processing Loop Guard:", err);
            }
        }

        hands.onResults(onResults);

        function processGesture(landmarks) {
            // Screen coords to World coords
            // Landmarks are 0.0 to 1.0
            // Wrist (0), Index Base (5), Index Tip (8), Thumb Tip (4), Thumb Base (2)

            const indexTip = landmarks[8];
            const indexBase = landmarks[5];
            const thumbTip = landmarks[4];
            const thumbBase = landmarks[2];

            // Map hand to camera space
            // Mirroring: landmarks.x is 0(left screen) to 1(right screen)
            // But we display mirrored video, so we adjust
            const gunDir = new THREE.Vector3(
                (0.5 - indexTip.x) * 10,
                (0.5 - indexTip.y) * 10,
                -5
            );

            // Set Laser Line
            laserLine.visible = true;
            laserLine.geometry.setFromPoints([
                new THREE.Vector3(0, -2, -2), // Source (approx hip/chest height)
                gunDir
            ]);

            // Snap Crosshair UI
            const crosshair = document.getElementById('crosshair');
            const screenX = (1 - indexTip.x) * window.innerWidth;
            const screenY = indexTip.y * window.innerHeight;

            // Magnetic Aim Assist logic
            let bestTarget = null;
            let minDist = 0.15; // Normalized screen distance for attraction

            state.enemies.forEach(e => {
                const vec = e.mesh.position.clone().project(camera);
                const ex = (vec.x + 1) / 2 * window.innerWidth;
                const ey = -(vec.y - 1) / 2 * window.innerHeight;
                const d = Math.hypot(screenX - ex, screenY - ey) / window.innerWidth;
                if (d < minDist) {
                    minDist = d;
                    bestTarget = { x: ex, y: ey, enemy: e };
                }
            });

            if (bestTarget) {
                crosshair.style.left = `${bestTarget.x}px`;
                crosshair.style.top = `${bestTarget.y}px`;
                crosshair.style.borderColor = "#facc15"; // Yellow snap
            } else {
                crosshair.style.left = `${screenX}px`;
                crosshair.style.top = `${screenY}px`;
                crosshair.style.borderColor = "#22d3ee"; // Cyan normal
            }

            // TRIGGER LOGIC: Thumb distance to Index base
            const distThumb = Math.hypot(thumbTip.x - indexBase.x, thumbTip.y - indexBase.y);
            const isTriggerClosed = distThumb < 0.1;

            if (isTriggerClosed && !state.lastTriggerState) {
                fire(bestTarget ? bestTarget.enemy : null, gunDir);
            }
            state.lastTriggerState = isTriggerClosed;
        }

        function fire(target, dir) {
            playSfx(150, 'square', 0.05);

            if (target) {
                target.shatter();
                state.score += 100;
                scoreEl.innerText = state.score.toString().padStart(4, '0');
            } else {
                // MISS
                playSfx(80, 'sawtooth', 0.1);
                createVfxText("MISS", dir);
            }
        }

        // Main Loop
        function animate() {
            requestAnimationFrame(animate);

            state.enemies.forEach(e => e.update());

            renderer.render(scene, camera);
        }

        // Performance Limited Detection Loop
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                if (!state.isInitialized) return;
                await hands.send({ image: videoElement });
            },
            width: 640,
            height: 480
        });

        // Initialize App
        window.onload = async () => {
            try {
                loadingText.innerText = "Requesting Camera Access...";
                videoElement.setAttribute('playsinline', '');
                await cameraUtils.start();

                loadingText.innerText = "Warming up AI Models...";
                // Small delay to ensure MediaPipe is ready
                setTimeout(() => {
                    state.isInitialized = true;
                    loadingOverlay.style.opacity = '0';
                    setTimeout(() => loadingOverlay.remove(), 500);
                    animate();
                }, 2000);
            } catch (err) {
                loadingText.innerText = "Error: " + err.message;
                console.error(err);
            }
        };

        // Handle Resize
        function handleResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);

            canvasElement.width = window.innerWidth;
            canvasElement.height = window.innerHeight;
        }
        window.addEventListener('resize', handleResize);
        handleResize(); // Initial call
    </script>
</body>

</html>